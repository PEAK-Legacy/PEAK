"""Basic implementation of a domain metamodel

    TODO:

    * Add feature list metadata support into default metaclasses

    * Review metaclass names and standardize naming convention

    * Ability to define preferred sequence of features (needed for XMI.field
      support, perhaps useful for autogenerated UI's as well?)
"""

from peak.api import *

from interfaces import *
from method_exporter import MethodExporter


__all__ = [
    'Immutable', 'Namespace', 'Package', 'Model', 'FeatureMC',
    'StructuralFeature', 'Field', 'Collection', 'Reference', 'Sequence',
    'Classifier','PrimitiveType','Enumeration','DataType',
    'DerivedAssociation', 'HashAndCompare'
]


class HashAndCompare(object):

    """Mixin that allows 'hash' and 'cmp' operations on a delegate value"""

    def __hash__(self):
        return hash(self._hashAndCompare)

    def __cmp__(self,other):
        return cmp(self._hashAndCompare,other)






class Namespace(binding.Base):

    def _XMIMap(self,d,a):

        xm = {}

        for m in binding.getInheritedRegistries(self,'_XMIMap'):
            xm.update(m)

        for k,v in self.__class_descriptors__.iteritems():
        
            for n in getattr(v,'_XMINames',()):

                xm[n] = k

                while '.' in n:
                    n = n.split('.',1)[1]
                    xm[n]=k

        return xm

    _XMIMap = binding.classAttr(binding.Once(_XMIMap))


class Package(Namespace):

    """Package of Element Classes"""


class Model(Package):

    """Model or Metamodel containing Packages or Element classes"""









class FeatureMC(HashAndCompare,MethodExporter):

    """Method-exporting Property
    
        This metaclass adds property support to Meta.MethodExporter by adding
        '__get__', '__set__', and '__delete__' methods, which are delegated
        to the method templates for the 'get', 'set' and 'delattr' verbs.

        In other words, if you define a feature 'foo', following standard
        naming patterns for its 'set', 'get' and 'delattr' verbs, and 'bar' is
        an Element whose class includes the 'foo' feature, then 'bar.foo = 1'
        is equivalent to 'bar.setFoo(1)'.  Similarly, referencing 'bar.foo' by
        itself is equivalent to 'bar.getFoo()', and 'del bar.foo' is equivalent
        to 'bar.delattrFoo()'.

        (Note: this is true even if the Element class supplies its own 'setFoo'
        or 'getFoo' implementations, since the 'getMethod()' API is used.)

        Please see the 'TW.API.Meta.MethodExporter' class documentation for
        more detail on how method templates are defined, the use of naming
        conventions, verbs, template variants, etc."""

    __metaclass__ = binding.Activator   # metaclasses can't be components


    def __get__(self, ob, typ=None):

        """Get the feature's value by delegating to 'ob.getX()'"""

        if ob is None: return self
        return self.getMethod(ob,'get')()


    def __set__(self, ob, val):

        """Set the feature's value by delegating to 'ob.setX()'"""

        return self.getMethod(ob,'set')(val)



    def __delete__(self, ob):

        """Delete the feature's value by delegating to 'ob.delattrX()'"""

        return self.getMethod(ob,'unset')()


    def typeObject(self,d,a):
        rt = self.referencedType
        if isinstance(rt,str):
            return binding.lookupComponent(rt,self)
        return rt

    typeObject = binding.Once(typeObject)


    fromString = binding.bindTo('typeObject/fromString')
    fromFields = binding.bindTo('typeObject/fromFields')

    sortPosn   = None

    def _hashAndCompare(self,d,a):
        return self.sortPosn, self.__name__, id(self)
        
    _hashAndCompare = binding.Once(_hashAndCompare)


    def featureName(self,d,a):
        return self.__name__.split('.')[-1]

    featureName = binding.Once(featureName)










class StructuralFeature(object):

    __metaclass__ = FeatureMC
    __class_implements__ = IFeature

    isDerived     = False
    isRequired    = False

    isOrdered     = False
    isChangeable  = True    # default is to be changeable

    lowerBound    = 0
    upperBound    = None    # None means unbounded upper end

    isMany     = binding.classAttr(binding.Once(lambda s,d,a: s.upperBound<>1))
    isRequired = binding.classAttr(binding.Once(lambda s,d,a: s.lowerBound >0))

    referencedEnd  = None    # and without an 'other end'
    referencedType = None
    defaultValue   = None

    newVerbs = Items(
        get     = 'get%(initCap)s',
        set     = 'set%(initCap)s',
        unset   = 'unset%(initCap)s',
    )
    
    def get(feature, element):
        return element._getBinding(feature.attrName, feature.defaultValue)


    def set(feature, element, val):
        element._setBinding(feature.attrName,val)

    def unset(feature, element):
        element._delBinding(feature.attrName)





class Field(StructuralFeature):

    __class_implements__ = IValue    

    upperBound = 1

    def _getList(feature, element):
        return [feature.get(element)]



class DerivedAssociation(StructuralFeature):

    isDerived = 1

    def _getList(feature, element):
        """This must be defined in subclass"""
        raise NotImplementedError
        
    def get(feature, element):
        return feature._getList(element)

    def set(feature, element, val):
        raise TypeError(
            "DerivedAssociation %s cannot be changed" % feature.attrName
        )

    def unset(feature, element):
        raise TypeError(
            "DerivedAssociation %s cannot be changed" % feature.attrName
        )
        









class Collection(StructuralFeature):

    __class_implements__ = ICollection

    newVerbs = Items(
        add     = 'add%(initCap)s',
        remove  = 'remove%(initCap)s',
        replace = 'replace%(initCap)s',
    )

    def _getList(feature, element):
        return element._getBinding(feature.attrName, [])
        
    def get(feature, element):
        return feature._getList(element)

    def set(feature, element, val):
        feature.__delete__(element)
        map(feature.getMethod(element,'add'),val)


    def add(feature, element, item):
        """Add the item to the collection/relationship"""      

        ub = feature.upperBound

        if not ub or len(feature._getList(element))<ub:
            feature._notifyLink(element,item)
        else:
            raise ValueError("Too many items")


    def remove(feature, element, item):
        """Remove the item from the collection/relationship, if present"""
        feature._notifyUnlink(element,item)






    def replace(feature, element, oldItem, newItem):

        d = feature._getList(element)
        p = d.index(oldItem)

        if p!=-1:
            feature._notifyUnlink(element,oldItem,p)
            feature._notifyLink(element,newItem,p)
        else:
            raise ValueError(oldItem,"not found")


    def unset(feature, element):

        """Unset the value of the feature (like __delattr__)"""

        d = feature._getList(element)

        items = zip(range(len(d)),d)
        items.reverse()

        unlink = feature._notifyUnlink

        # remove items in reverse order, to simplify deletion and
        # to preserve any invariant that was relevant for addition
        # order...
        
        for posn,item in items:
            unlink(element,item,posn)
            
        element._delBinding(feature.attrName)










    def _notifyLink(feature, element, item, posn=None):

        feature._link(element,item,posn)
        referencedEnd = feature.referencedEnd

        if referencedEnd:
            otherEnd = getattr(item.__class__,referencedEnd)
            otherEnd._link(item,element)


    def _notifyUnlink(feature, element, item, posn=None):

        feature._unlink(element,item,posn)
        referencedEnd = feature.referencedEnd

        if referencedEnd:
            otherEnd = getattr(item.__class__,referencedEnd)
            otherEnd._unlink(item,element)


    def _link(feature,element,item,posn=None):

        d=feature._getList(element)
        element._setBinding(feature.attrName, d)

        if posn is None:
            d.append(item)
        else:
            d.insert(posn,item)
        

    def _unlink(feature,element,item,posn=None):

        d=feature._getList(element)
        element._setBinding(feature.attrName, d)

        if posn is None:
            d.remove(item)
        else:
            del d[posn]

class Reference(Collection):

    __class_implements__ = IReference

    upperBound = 1


    def get(feature, element):
        vals = feature._getList(element)
        if vals: return vals[0]


    def set(feature, element, val):
        feature.__delete__(element)
        feature.getMethod(element,'add')(val)


























class Sequence(Collection):

    __class_implements__ = ISequence

    isOrdered = 1

    newVerbs = Items(
        insertBefore = 'insert%(initCap)sBefore',
    )


    def insertBefore(feature, element, oldItem, newItem):

        d = feature._getList(element)
        
        ub = feature.upperBound
        if ub and len(d)>=ub:
            raise ValueError("Too many items")

        i = -1
        if d: i = d.index(oldItem)

        if i!=-1:
            feature._notifyLink(element,newItem,i)
        else:
            raise ValueError(oldItem,"not found")















class Classifier(Namespace):

    """Basis for all flavors"""

    def mdl_featuresDefined(self,d,a):

        """Sorted tuple of feature objects defined/overridden by this class"""

        isFeature = IFeature.isImplementedBy
        mine = [v for (k,v) in d.items() if isFeature(v)]
        mine.sort()
        return tuple(mine)

    mdl_featuresDefined = binding.classAttr(
        binding.Once(mdl_featuresDefined)
    )


    def mdl_featureNames(self,d,a):
        """Names of all features, in monotonic order (see 'mdl_features')"""
        return tuple([f.featureName for f in self.mdl_features])

    mdl_featureNames = binding.classAttr(binding.Once(mdl_featureNames))


    def mdl_sortedFeatures(self,d,a):

        """All feature objects of this classifier, in sorted order"""

        fl = list(self.mdl_features)
        fl.sort
        return tuple(fl)

    mdl_sortedFeatures = binding.classAttr(binding.Once(mdl_sortedFeatures))







    def mdl_features(self,d,a):
        """All feature objects of this classifier, in monotonic order

        The monotonic order of features is equivalent to the concatenation of
        'mdl_featuresDefined' for all classes in the classifier's MRO, in
        reverse MRO order, with duplicates (i.e. overridden features)
        eliminated.  That is, if a feature named 'x' exists in more than one
        class in the MRO, the most specific definition of 'x' will be used
        (i.e. the first definition in MRO order), but it will be placed in the
        *position* reserved by the *less specific* definition.  The idea is
        that, once a position has been defined for a feature name, it will
        continue to be used by all subclasses, if possible.  For example::

            class A(model.Classifier):
                class foo(model.Field): pass
                
            class B(A):
                class foo(model.Field): pass
                class bar(model.Field): pass

        would result in 'B' having a 'mdl_features' order of '(foo,bar)',
        even though its 'mdl_featuresDefined' would be '(bar,foo)' (because
        features without a sort priority define are ordered by name).

        The purpose of using a monotonic ordering like this is that it allows
        subtypes to use a serialized format that is a linear extension of
        their supertype, at least in the case of single inheritance.  It may
        also be useful for GUI layouts, where it's also desirable to have a
        subtype's display look "the same" as a base type's display, except for
        those features that it adds to the supertype."""
        
        out  = []
        posn = {}
        add  = out.append
        get  = posn.get

        all  = list(
            binding.getInheritedRegistries(self,'mdl_features')
        )
        all.append(self.mdl_featuresDefined)
      
        for nf in all:
            for f in nf:
                n = f.featureName
                p = get(n)
                if p is None:
                    posn[n] = len(out)
                    add(f)
                else:
                    out[p] = f
                    
        return tuple(out)

    mdl_features = binding.classAttr( binding.Once(mdl_features) )




























class ImmutableClass(Classifier.__class__):

    def __init__(klass,name,bases,dict):
        for f in klass.mdl_features:
            if f.isChangeable:
                raise TypeError(
                    "Immutable class with changeable feature",
                    klass, f
                )
        super(ImmutableClass,klass).__init__(name,bases,dict)


class Immutable(Classifier, HashAndCompare):

    __metaclass__ = ImmutableClass

    def _hashAndCompare(s,d,a):
        return tuple([
            getattr(s,n,None) for n in s.__class__.mdl_featureNames
        ])

    _hashAndCompare = binding.Once(_hashAndCompare)

    def setParentComponent(self, parentComponent, componentName=None):
        if parentComponent is not None or componentName is not None:
            raise TypeError("Data values are not components")
    
    def getParentComponent(self):
        return None

    def getComponentName(self):
        return None

    def _setBinding(self,attr,value):
        raise TypeError("Immutable object", self)

    def __setattr__(self,attr,value):
        raise TypeError("Immutable object", self)



class PrimitiveType(Immutable):

    """A primitive type (e.g. Boolean, String, etc.)"""

    def fromString(klass, value):
        return value

    fromString = classmethod(fromString)


class Enumeration(Immutable):

    """An enumeration type"""

    def __value_map__(klass,d,a):

        values = {}

        map(values.update,
            binding.getInheritedRegistries(klass,'__value_map__')
        )

        values.update(klass.__dict__.get('__values__',{}))

        for k,v in klass.__dict__.items():
            if not k.startswith('__') or not k.endswith('__'):
                values[k]=v

        return values

    __value_map__ = binding.classAttr(binding.Once(__value_map__))


    def fromString(klass, value):
        if value in klass.__value_map__:
            return klass.__value_map__[value]
        raise ValueError, value

    fromString = classmethod(fromString)


class DataType(Immutable):

    """A complex datatype"""

    def fromString(klass, value):
        return value

    fromString = classmethod(fromString)

    def fromFields(klass, fields):
        raise NotImplementedError

    fromFields = classmethod(fromFields)
























