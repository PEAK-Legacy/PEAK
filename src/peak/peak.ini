[peak.config.iniFile.sectionParsers]

# This section defines how special '[section name]' sections will be parsed.
# If a section name contains inner spaces, it is looked up here by lowercasing
# it, and converting contiguous whitespace to '.'.  The returned object or
# function must implement config.ISettingParser.  This essentially makes .ini
# syntax extensible, at least with regard to how the contents of name=value
# pairs are interpreted.  Later in the file, we'll see uses of each of the
# following section headers.

load.settings.from = "peak.config.config_components.do_include"
provide.utilities  = "peak.config.config_components.provide_utility"
load.on.demand     = "peak.config.config_components.on_demand"


[peak.config.loaders]

# This section defines the types of data that can be used in
# "[Load Settings From]" sections.  Each entry is either the loading function
# to be used, or an import string specifying the loading function.  Loading
# functions must conform to the 'config.ISettingLoader' interface.

file    = "peak.config.config_components:loadConfigFile"
files   = "peak.config.config_components:loadConfigFiles"
mapping = "peak.config.config_components:loadMapping"
















[Load on Demand]

# Settings in load-on-demand sections are evaluated once and *only* once,
# when a property under their namespace isn't found.  The code is expected to
# load property settings into the supplied 'propertyMap', and return the value
# for property 'propertyName', if found.  It's safe to simply return NOT_FOUND,
# in which case the configuration machinery will check to see if a new rule was
# loaded for the desired property.
#
# Again, note that the code is only run *once*, *ever*.  It doesn't get a
# 'targetObj' because it's intended to load rules that will be used in place of
# itself thereafter.  So load-on-demand sections are only useful for loading
# other rules, within a prescribed property namespace.

peak.running.cluster.* =

    importString('peak.running.clusters:loadCluster')(
        propertyMap,
        config.getProperty(propertyMap, '__main__.CLUSTER', default=None),
        ruleName, propertyName,
    )




















[peak.web]

# Default services, protocols, and options for 'peak.web' applications

appLog         = naming.lookup(targetObj, 'logging.logger:web.app')
defaultMethod  = 'index_html'
resourcePrefix = '++resources++'

pathProtocol  = web.IWebTraversable
pageProtocol  = web.IWebPage
errorProtocol = web.IWebException

authenticationService = web.NullAuthenticationService
interactionClass      = web.Interaction
skinService           = web.NullSkinService()

# Configuration file to load for "root" resource directories
resourceDefaultsIni = config.fileNearModule('peak.web','resource_defaults.ini')

# Local configuration file in *each* resource directory, if present
resourceConfigFile  = 'resources.ini'

# Factory to use for package resource directories
packageResourceFactory = importString("peak.web.resources:ResourceDirectory")

# The default request classes used for each HTTP variant
HTTPRequest    = importString('peak.web.requests.HTTPRequest')
BrowserRequest = importString('peak.web.requests.BrowserRequest')
XMLRPCRequest  = importString('peak.web.requests.XMLRPCRequest')


[peak.web.resource_packages]

# Property names with true values under this namespace indicate packages that
# are safe to publish resources from, e.g.:
#
#   peak.* = True
#
# would allow any data files in any peak.* package to be downloadable.  Be
# careful what you define here.

[peak.web.DOMlets]

# "built-in" DOMlet classes for peak.web; you can add your own per-app

text   = importString('peak.web.templates.Text')
list   = importString('peak.web.templates.List')
url.*  = importString('peak.web.templates.URLTag')


[peak.naming]

initialContextFactory = "peak.naming.contexts:EmptyContext"
creationParent  = None
schemeParser    = None


[peak.naming.factories]

# Import name mappings for naming system object factories.
# By default, any property name under peak.naming.factories returns itself,
# minus the peak.naming.factories prefix.

* = ruleSuffix


















[peak.naming.schemes]

# This section defines naming context factories or URL.Base subclasses to
# be used for various URL schemes.  The entry name is the URL scheme, and
# the value is either the object or an import string for loading it.

import  = "peak.naming.factories.peak_imports:importContext"
smtp    = "peak.naming.factories.smtp:smtpURL"
uuid    = "peak.naming.factories.uuid:uuidURL"
nis     = "peak.naming.factories.nisns:nisURLContext"
config  = "peak.naming.factories.config_ctx:PropertyContext"

ldap    = "peak.storage.LDAP:ldapURL"
sybase  = "peak.storage.SQL:GenericSQL_URL"
pgsql   = "peak.storage.SQL:GenericSQL_URL"
psycopg = "peak.storage.SQL:GenericSQL_URL"
mockdb  = "peak.storage.SQL:GenericSQL_URL"
gadfly  = "peak.storage.SQL:GadflyURL"
sqlite  = "peak.storage.SQL:SqliteURL"
cxoracle = "peak.storage.SQL:OracleURL"
dcoracle2 = "peak.storage.SQL:OracleURL"

logfile = "peak.running.logs:logfileURL"
logging.logger = "peak.running.logs:peakLoggerContext"

lockfile     = "peak.running.lockfiles:lockfileURL"
nulllockfile = "peak.running.lockfiles:lockfileURL"
shlockfile   = "peak.running.lockfiles:lockfileURL"
flockfile    = "peak.running.lockfiles:lockfileURL"
winflockfile = "peak.running.lockfiles:lockfileURL"
win32.dde    = "peak.storage.DDE:ddeURL"

http    = "peak.naming.factories.openable:OpenableURL"
ftp     = "peak.naming.factories.openable:OpenableURL"
https   = "peak.naming.factories.openable:OpenableURL"
file    = "peak.naming.factories.openable:FileURL"
pkgfile = "peak.naming.factories.openable:PkgFileURL"
icb     = "peak.net.icb:ICB_URL"



tcp     = "peak.net.sockets.tcpudpURL"
udp     = "peak.net.sockets.tcpudpURL"
unix    = "peak.net.sockets.unixURL"
unix.dg = "peak.net.sockets.unixURL"
fd	= "peak.net.sockets.fdURL"

zconfig.schema = "peak.config.load_zconfig:ZConfigSchemaContext"
shellcmd = "peak.naming.factories.shellcmd:ShellCommandCtx"


# Data type conversion for database drivers

[Sybase.sql_types]
* = config.Namespace('peak.sql_types')

[pgdb.sql_types]
* = config.Namespace('peak.sql_types')

[sqlite.sql_types]
* = config.Namespace('peak.sql_types')

[gadfly.sql_types]
* = config.Namespace('peak.sql_types')

[cx_Oracle.sql_types]
* = config.Namespace('peak.sql_types')

[DCOracle2.sql_types]
* = config.Namespace('peak.sql_types')













[peak.metamodels.mof1.3.writers]

# Functions that can generate objects or code from MOF models

peak.model  = "peak.model.mof2py:MOFGenerator.externalize"
outline     = "peak.model.mof2py:MOFOutline.externalize"
fileset     = "peak.model.mof2py:MOFFileSet.externalize"



[peak.xmi.metamodels]

# Metamodels to be used when loading XMI files - if you discover a usage
# of one of these "in the wild" that doesn't match up on the left hand side
# here, please let us know.

UML.1.3               = importString('peak.metamodels:UML13')
UML.1.4               = importString('peak.metamodels.UML14:UML')
Model.1.3             = importString('peak.metamodels:MOF131')
org.omg.mof.Model.1.3 = importString('peak.metamodels:MOF131')
peak.tests.MailModel  = importString('peak.storage.tests:xmi')



[peak.running]

# peak.running.mainLoop.signalHandler is used while the standard MainLoop runs
mainLoop.signalHandler =
    importString('peak.running.scheduler:StopOnStandardSignals')(targetObj)

# This setting only affects the 'UntwistedReactor'
reactor.checkInterval = 3600    # if no scheduled tasks, do 1 select/hour









[peak.running.shortcuts]

# Shortcut names for 'peak' bootstrap script - supplied values must
# implement the 'running.IExecutable' interface; see the interface docs
# for details.

# 'runIni' launches an interpreter that expects a file formatted like this
# one, with an 'IExecutable' in its 'peak.running.app' property.
runIni = importString('peak.running.commands:IniInterpreter')

# 'CGI' runs its next argument by looking it up and adapting it to an
# IRerunnableCGI; shortcut names may be used.
CGI = importString('peak.running.commands:CGIInterpreter')

# 'ZConfig' loads its next command line argument (a URL or filename) as a
# ZConfig schema, that then loads the next command line argument as a ZConfig
# data file that follows the specified schema.
ZConfig = importString('peak.running.commands:ZConfigInterpreter')

# 'EventDriven' runs a 'running.commands.EventDriven' application, configured
# via a ZConfig file using the 'peak.runnning/EventDriven.xml' schema.  This
# only supports PEAK built-in task types, so if you add your own task types
# you'll need to create a new schema and have it extend EventDriven.xml.
EventDriven =
    naming.LinkRef('zconfig.schema:pkgfile:peak.running/EventDriven.xml')

# These are just cute emulations of '/bin/true' and '/bin/false';
# of course they're *much* slower than the real ones!
true = lambda: 0
false = lambda: 1

# Run peak's unit tests
test = importString('peak.running.commands:TestRunner')

# PEAK's Namespace Navigator
n2 = importString('peak.running.tools.n2.main:N2')





# 'supervise' multiprocess manager
supervise =
    naming.LinkRef('zconfig.schema:pkgfile:peak.running/Supervisor.xml')

# 'FastCGI' port listener
FastCGI = importString('peak.running.supervisor:FCGITemplateCommand')


# PEAK versioning tool

version-config =
    importString('peak.running.commands:Alias')(
        targetObj,
        command = [
            'runIni',
            config.fileNearModule('peak.running.tools.version','version.ini')
        ]
    )



[peak.logs]

# Routing for peak-supplied log messages - default is to log WARNING or
# higher to 'sys.stderr'

* = logs.LogStream(stream=importString('sys.stderr'), level=logs.WARNING)














[Provide Utilities]

# "Provide Utilities" sections define utilities by mapping from an import
# string for an interface, to an expression defining the Provider.
#
# Note that unlike property sections, code in "Provide utilities" sections is
# executed immediately to create a provider rule, not on-demand when the
# utility is actually requested, so you should avoid code that does unnecessary
# importing.  You'll notice that most providers shown here do their imports
# inside of lambdas within config.provideInstance() or
# config.instancePerComponent() calls.

# This first provider associates a default transaction service with the
# nearest AppConfig above the object that the service is wanted for.  It
# creates a TransactionService instance with that config as its parent
# component.

peak.storage.interfaces.ITransactionService =
    config.provideInstance('peak.storage.transactions.TransactionService')

# Some similar services for peak.running:

peak.running.interfaces.ISignalManager =
    config.provideInstance('peak.running.process.SignalManager')

peak.running.interfaces.IMainLoop =
    config.provideInstance('peak.running.scheduler.MainLoop')

peak.running.interfaces.ITaskQueue =
    config.provideInstance('peak.running.daemons.TaskQueue')

peak.running.interfaces.IBasicReactor =
    config.provideInstance('peak.running.scheduler.getReactor')

peak.running.interfaces.ITwistedReactor =
    config.provideInstance('peak.running.scheduler.getTwisted')





[__main__]
# The '__main__' namespace will be used by PEAK for global settings that
# can be set either in the application's main startup script (i.e. the
# Python '__main__' module) or the environment.  The following rule
# sets up a fallback from the '__main__' namespace to the 'environ'
# namespace, so that anything not supplied by the startup script will
# be supplied by the environment.

* = config.Namespace('environ.*')

[Load Settings From]
# "Load Settings From" sections are processed in-line to load settings from
# other sources.  'file=' entries act like "include" operations, loading
# configuration files in the same format.  'mapping=' entries load Python
# mapping objects.  The first argument is the filename or mapping object,
# respectively, and the second argument, if present, is a prefix to be used
# on property names found in the specified mapping or file.
#
# Note that "Load Settings From" sections are executed at the point where they
# appear in the file, and a snapshot of the data source is taken at that time.
# If a data source (file, mapping, etc.) changes later, it will have no effect
# on the settings that were already loaded, although you can always load the
# settings again (assuming none of them have been used yet).
#
# In this section of peak.ini, we initialize the 'environ.*' namespace from
# Python's 'os.environ' mapping, and the '__main__.*' namespace from the
# '__main__' (startup) module's dictionary.  Finally, we load the configuration
# file(s) specified by '__main__.PEAK_CONFIG', which allows a script to simply
# set PEAK_CONFIG to specify its main configuration file, or if not set, it
# will fall back to the PEAK_CONFIG environment variable.

mapping = importString('os.environ'),        'environ.*'
mapping = importString('__main__').__dict__, '__main__.*'

files   =
    config.getProperty(
        propertyMap, '__main__.PEAK_CONFIG', default=''
    ).split(importString('os.pathsep'))



