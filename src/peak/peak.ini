[peak.config.loaders]

# This section defines the types of data that can be used in
# "[Load Settings From]" sections.  Each entry is either the loading function
# to be used, or an import string specifying the loading function.  Loading
# functions must conform to the 'config.ISettingLoader' interface.

file    = "peak.config.config_components:loadConfigFile"
mapping = "peak.config.config_components:loadMapping"




[Load on Demand]

# Settings in load-on-demand sections are evaluated once and *only* once,
# when a property under their namespace isn't found.  The code is expected to
# load property settings into the supplied 'propertyMap', and return the value
# for property 'propertyName', if found.  It's safe to simply return NOT_FOUND,
# in which case the configuration machinery will check to see if a new rule was
# loaded for the desired property.
#
# Again, note that the code is only run *once*, *ever*.  It doesn't get a
# 'targetObj' because it's intended to load rules that will be used in place of
# itself thereafter.  So load-on-demand sections are only useful for loading
# other rules, within a prescribed property namespace.

peak.running.cluster.* =

    importString('peak.running.clusters:loadCluster')(
        propertyMap,
        config.getProperty('__main__.CLUSTER', propertyMap, default=None),
        ruleName, propertyName,
    )







[peak.naming]

initialContextFactory = "peak.naming.contexts:NameContext"

creationName    = None
creationParent  = None
schemeParser    = None
objectFactories = list(findUtilities(naming.IObjectFactory, targetObj))
stateFactories  = list(findUtilities(naming.IStateFactory,  targetObj))

[peak.naming.schemes]

# This section defines naming context factories or ParsedURL subclasses to
# be used for various URL schemes.  The entry name is the URL scheme, and
# the value is either the object or an import string for loading it.

import  = "peak.naming.factories.peak_imports:importURL"
smtp    = "peak.naming.factories.smtp:smtpURL"
uuid    = "peak.naming.factories.uuid:uuidURL"
nis     = "peak.naming.factories.nisns:nisURLContext"
config  = "peak.naming.factories.config_ctx:PropertyContext"

ldap    = "peak.storage.LDAP:ldapURL"
sybase  = "peak.storage.SQL:GenericSQL_URL"
pgsql   = "peak.storage.SQL:GenericSQL_URL"
gadfly  = "peak.storage.SQL:GadflyURL"
logfile = "peak.running.logs:logfileURL"

lockfile    = "peak.running.lockfiles:lockfileURL"
nulllockfile= "peak.running.lockfiles:lockfileURL"
shlockfile  = "peak.running.lockfiles:lockfileURL"
flockfile   = "peak.running.lockfiles:lockfileURL"
winflockfile= "peak.running.lockfiles:lockfileURL"
win32.dde   = "peak.storage.DDE:ddeURL"

http   = "peak.naming.factories.openable:OpenableURL"
ftp    = "peak.naming.factories.openable:OpenableURL"
https  = "peak.naming.factories.openable:OpenableURL"
file   = "peak.naming.factories.openable:OpenableURL"
gopher = "peak.naming.factories.openable:OpenableURL"

[peak.metamodels.mof1.3.writers]

# Functions that can generate objects or code from MOF models

peak.model  = "peak.model.mof2py:MOFGenerator.externalize"
outline     = "peak.model.mof2py:MOFOutline.externalize"
fileset     = "peak.model.mof2py:MOFFileSet.externalize"



[peak.xmi.metamodels]

# Metamodels to be used when loading XMI files - if you discover a usage
# of one of these "in the wild" that doesn't match up on the left hand side
# here, please let us know.

UML.1.3               = importString('peak.metamodels:UML13')
Model.1.3             = importString('peak.metamodels:MOF131')
org.omg.mof.Model.1.3 = importString('peak.metamodels:MOF131')
peak.tests.MailModel  = importString('peak.storage.tests:xmi')





















[Provide Utilities]

# "Provide Utilities" sections define utilities by mapping from an import
# string for an interface, to an expression defining the Provider.
#
# Note that unlike property sections, code in "Provide utilities" sections is
# executed immediately to create a provider rule, not on-demand when the
# utility is actually requested, so you should avoid code that does unnecessary
# importing.  You'll notice that the providers shown here do their imports
# inside of lambdas within config.Provider() calls.

# Our first provider is a global default for the 'naming.IObjectFactory'
# interface, which "bottoms out" the search for object factories by providing
# default behavior for creating objects from state found in a naming context.

peak.naming.interfaces.IObjectFactory =
    lambda *args: importString('peak.naming.spi')

# This next provider associates a default transaction service with the
# nearest AppConfig above the object that the service is wanted for.  It
# creates a TransactionService instance with that config as its parent
# component.

peak.storage.interfaces.ITransactionService =
    config.instancePerApp('peak.storage.transactions.TransactionService')

# Some similar services for peak.running:

peak.running.interfaces.IMainLoop = 
    config.instancePerApp('peak.running.scheduler.MainLoop')

peak.running.interfaces.ITaskQueue =
    config.instancePerApp('peak.running.daemons.TaskQueue')

peak.running.interfaces.IBasicReactor =
    config.instancePerApp('peak.running.scheduler.getReactor')

peak.running.interfaces.ITwistedReactor =
    config.instancePerApp('peak.running.scheduler.getTwisted')


[__main__]

# The '__main__' namespace will be used by PEAK for global settings that
# can be set either in the application's main startup script (i.e. the
# Python '__main__' module) or the environment.  The following rule
# sets up a fallback from the '__main__' namespace to the 'environ'
# namespace, so that anything not supplied by the startup script will
# be supplied by the environment.

* = config.getProperty(
        'environ.'+propertyName.split('.',1)[1], default=NOT_FOUND
    )

[Load Settings From]

# "Load Settings From" sections are processed in-line to load settings from
# other sources.  'file=' entries act like "include" operations, loading
# configuration files in the same format.  'mapping=' entries load Python
# mapping objects.  The first argument is the filename or mapping object,
# respectively, and the second argument, if present, is a prefix to be used
# on property names found in the specified mapping or file.
#
# Note that "Load Settings From" sections are executed at the point where they
# appear in the file, and a snapshot of the data source is taken at that time.
# If a data source (file, mapping, etc.) changes later, it will have no effect
# on the settings that were already loaded, although you can always load the
# settings again (assuming none of them have been used yet).
#
# In this section of peak.ini, we initialize the 'environ.*' namespace from
# Python's 'os.environ' mapping, and the '__main__.*' namespace from the
# '__main__' (startup) module's dictionary.  Finally, we load a configuration
# file specified by '__main__.PEAK_CONFIG', which allows a script to simply
# set PEAK_CONFIG to specify its main configuration file, or if not set, it
# will fall back to the PEAK_CONFIG environment variable.

mapping = importString('os.environ'),        'environ.*'
mapping = importString('__main__').__dict__, '__main__.*'

file    = config.getProperty('__main__.PEAK_CONFIG', default=None)


