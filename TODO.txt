Open Issues/To-Do Items

 Release Checklist for 0.5 Alpha 1

    - Unit tests for event-driven operations: IMainLoop, IPeriodicTask, and ITaskQueue

    - Cleanup/document attribute binding mechanism as an 'IAttributeBinding' interface

    - Make all API signatures start with context component

    - Finalize name for 'config.Application' - probably 'config.DefaultContext'

    - Review binding tutorial and correct any errors relative to current APIs

    - Add 'fcgiapp' module sources to distribution; update README/INSTALL to credit
      DC and OpenMarket and reference their licenses.



Targeted for 0.5 Alpha 2

    * ZConfig Integration

      - A 'config.ZConfig' module that provides "PEAK-aware" versions of ZConfig
        services (e.g. it will use 'peak.naming' to resolve URLs)

      - App startup tools based on ZConfig files.

      - Sample 'AdaptiveTask' classes that perform the same functions as those in
        the MetaDaemon package, with a ZConfig schema to run them in a daemon-like
	application.

    * Fix issue w/reading XMI 1.1 files where metamodel has nested packages

    * Generate UML 1.4 and 1.5 and CWM 1.0 and 1.1, and add them to the
      'setup.py' package lists.

    * Get XMI writing in place, w/transaction support

    * Generate ZConfig schemas from 'peak.model' or MOF models?

    * 'peak.running' refactorings: use standard 'logging' module's log levels,
       add 'logging' distro to 'peak.util' for 2.2 backward compatibility,
       and possibly adjust cluster stuff to work off ZConfig primary and
       generate clustertools file(s).

    * 'peak.naming' refactorings: 'peak.model'-based syntax utilities for
       creating address syntaxes.


 Targeted for 0.5 Beta 1

    * Updated reference docstrings for 'peak.api', 'peak.binding',
      'peak.config', 'peak.exceptions', and 'peak.naming'.

    * Finish tutorial chapter 2 (?)

    * On-the-fly class combination (think "runtime module inheritance",
      without the modules) for DMs.























 Targeted for 0.5 Final Release (or sooner)

    General

        * Tutorial complete through chapter 4

    peak.storage

        - unit tests for more complex object scenarios: references, thunks..?

        - lock management interfaces/API

        - docstrings for reference

    peak.model

        - clean up TW docstrings & interfaces

    peak.naming

        - useful example "flat" naming context (e.g. like AppUtils.URLkeys)

        - useful example hierarchical naming context (e.g. like JNDI's LDAP
          context or filesystem context)

        - rework smtp: to return a factory object that supports open().
          Also think about whether smtp should move elsewhere. Maybe
          there should be peak.network or peak.internet for things like
          smtp, ftp, etc contexts?

    peak.running

        - make 'cluster' parser complain about things that would cause
          the clusterit tools to choke or barf on the file, or which would
          produce ambiguous or unintended results.

        - simple daemons comparable to those in MetaDaemon, unit tests

        - docstrings for reference


    peak.config

        - "Rule"-oriented configuration files (section specifies component
          rather than property name prefix), so that daemons and other simple
          apps can be fully configured and run via a config file.

    peak.util

        - docstrings for reference

        - more unit tests?






























 Future Releases

  (Note: some of the below is held-over from TransWarp and may no longer be
  relevant as written, they are being kept on this list as placeholders for
  ideas or problem areas that may need to be re-considered in future.)

  Miscellaneous

    * Functional tests that access "real" databases, LDAP, etc.

  Simulator/Module Inheritance

    * Allow 'declareModule()' to bootstrap non-existent modules; this might
      let us create "virtual packages" made by assembling other packages and
      modules.

    * Need a strategy for handling "del" operations; they are currently
      untrapped.  This might be okay under most circumstances, but need to
      consider edge cases.

    * 'makeClass()' should probably become part of the core API, where
      it can be used to resolve __metaclass__ conflicts during the first
      pass of importing a module (prior to running 'setupModule()')


  Messaging/ObjectSpaces

    * Support for sending and receiving remote cache invalidation
      messages between DataManagers.












  peak.model

    * Implement WarpCORE-oriented structural model, w/Querying support

    * "Indexed" version of in-memory model?


    Queries

       * Refactor to use interfaces, if appropriate

       * Incorporate into AbstractModel?

         - Pros:

           * Queries always available

           * Each StructuralModel implementation can easily include its own
             performance-tuned version of the basic items.

         - Con: default implementation doesn't perform well on large datasets

       * How much of framework needs extensibility?  Should the predicate
         classes be placed in the StructuralModel's namespace so that predicates
         have their meaning assigned by the StructuralModel implementation?
















  peak.metamodels.uml

    * Helper methods in Elements & Services for marshalling, common queries, etc.

    * Generator framework

      - Tagged values in stereotypes vs. main values?

      - Should tagged values be copied directly into templates?  Treated as
        Python expressions?

      - Should Services be generated using an Element class' "static"
        (class-scope) methods/attributes?

        - Are association-ends scoped?

        - Would it be better to seperate them?

      - What determines whether an implemented Service actually stores objects
        or delegates this to its subclass services?

    * Simple Zope product demo (upload XMI, then browse the model via the web)



















