Open Issues/To-Do Items

 Short Term Project Support

    * Add support for finding/registering plugins to 'peak.config'

      - Refactor IConfigKey to support explicit "namespace" concept

      - Refactor IPropertyMap -> IConfigMap, add iterability/search

        - Add inverted indexes for namespace lookups/search

        - Add 'IIterableConfigSource' (?) subclass, use for search funcs.

        - Lock namespaces that have been iterated over

      - Change existing configuration keys not to use tuples as surrogate keys

      - Add 'config.PluginsFor' key that finds plugins

        - May need 'suggestParentComponent()' to support dictionaries so plugin
          dictionaries will work correctly

        - Should it implement the "smart property" interface?

      - Things to look at during refactorings:

        - Better consolidation of config/component key and recipe interfaces?

        - Rule chaining

        - Use objects for section parsing instead of functions?

    * peak.storage

      - 'storage.dbType()'





 Targeted for 0.5 Alpha 3

    * peak.binding

      - Cleanup/document attribute binding interface

    * peak.running.logs

      - Add 'DefaultLoggingService', service-based system

      - Separate formatters from publishers

      - Loggers should know their names and pass that info to event constructor

    * peak.config

      - 'ZConfigSchemaService' and 'zconfig:schema@streamURL' scheme

    * peak.web (some of this may get bumped to alpha 4)

       - clean up DOMlet parse/build framework (e.g. add line number info)

       - default error templates, w/useful info

       - A set of simple, basic form controls that handle value rendering only
         (form metadata, validation, etc. will be handled by peak.web.forms in
         a later release)

       - try/catch DOMlet (and related error rendering interface/framework)












 Targeted for 0.5 Alpha 4

    * Transaction/storage refactorings

      - transaction scopes for commands and tasks

      - integrate locks with transactions

      - transactable persistent queues

      - DM.find()/DM.get() queries

    * peak.running.commands

       - Add option parsing framework based on optparse (backported to 2.2)

    * peak.config

       - Iterable keys to PropertyMap (rename to configMap?)

       - Writable and subscribable config sources, including editable .ini's

    * peak.web

       - allow use of // in DOMlets' data paths, to access resource space

       - DOMlets for layout/region, as defined in "A layout framework":http://www.eby-sarna.com/pipermail/transwarp/2003-August/000684.html

       - conditional GET support (last modified/ETag) for static resources

       - image resources

       - the return of the Specialist

    * Have a way to easily in-line custom component usage (e.g. automatically
      create a subclass component with specified 'Obtain' or 'Make' bindings to
      get its configuration).

    * Drop 'persistence' package, since ZODB 4 has been derailed.  Change to
      "state-delegation" model, which will integrate better with 'peak.query'.

 Targeted for 0.5 Beta 1

    * Up-to-date reference docstrings for all packages

    * Finish tutorial chapter 2 (?)

    * Web publishing framework sufficient to deploy page-based or object-
      published apps



 Targeted for 0.5 Final Release (or sooner)

    peak.storage

        - unit tests for more complex object scenarios: references, thunks..?

    peak.naming

        - useful example "flat" naming context (e.g. like AppUtils.URLkeys)

        - useful example hierarchical naming context (e.g. like JNDI's LDAP
          context or a filesystem context)

        - rework smtp: to return a factory object that supports open().
          Also think about whether smtp should move to peak.net?















 Targeted for version 0.6

   * Get XMI writing in place, w/transaction support

   * Generate UML 1.5 and CWM 1.0 and 1.1, and add them to the
     'setup.py' package lists.

   * On-the-fly class combination (think "runtime module inheritance",
     but possibly without the modules) for DMs.

   * Lock management interfaces/API for peak.storage

   * Make 'cluster' parser complain about things that would cause
     the clusterit tools to choke or barf on the file, or which would
     produce ambiguous or unintended results.  (Or replace with ZConfig
     schema that can generate clusterit files.  And/or replace clusterit
     tools with PEAK ones.)
























 Future Releases

  (Note: some of the below is held-over from TransWarp and may no longer be
  relevant as written, they are being kept on this list as placeholders for
  ideas or problem areas that may need to be re-considered in future.)

  Miscellaneous

    * Functional tests that access "real" databases, LDAP, etc.

  Simulator/Module Inheritance

    * Allow 'declareModule()' to bootstrap non-existent modules; this might
      let us create "virtual packages" made by assembling other packages and
      modules.

    * Need a strategy for handling "del" operations; they are currently
      untrapped.  This might be okay under most circumstances, but need to
      consider edge cases.

    * 'makeClass()' should probably become part of the core API, where
      it can be used to resolve __metaclass__ conflicts during the first
      pass of importing a module (prior to running 'setupModule()')


  Messaging/ObjectSpaces

    * Support for sending and receiving remote cache invalidation
      messages between DataManagers.












  peak.model

    * Implement WarpCORE-oriented structural model, w/Querying support

    * "Indexed" version of in-memory model?


    Queries

       * Refactor to use interfaces, if appropriate

       * Incorporate into AbstractModel?

         - Pros:

           * Queries always available

           * Each StructuralModel implementation can easily include its own
             performance-tuned version of the basic items.

         - Con: default implementation doesn't perform well on large datasets

       * How much of framework needs extensibility?  Should the predicate
         classes be placed in the StructuralModel's namespace so that predicates
         have their meaning assigned by the StructuralModel implementation?
















  peak.metamodels.uml

    * Helper methods in Elements & Services for marshalling, common queries, etc.

    * Generator framework

      - Tagged values in stereotypes vs. main values?

      - Should tagged values be copied directly into templates?  Treated as
        Python expressions?

      - Should Services be generated using an Element class' "static"
        (class-scope) methods/attributes?

        - Are association-ends scoped?

        - Would it be better to seperate them?

      - What determines whether an implemented Service actually stores objects
        or delegates this to its subclass services?

    * Simple demo (browse XMI model via the web)



















