Open Issues/To-Do Items

 Targeted for 0.5 Alpha 1

    * Finish tutorial chapter 2

    * Updated reference docstrings for 'peak.api', 'peak.binding',
      'peak.config', 'peak.exceptions', and 'peak.naming'.


 Targeted for 0.5 Final Release (or sooner)


    General

        * Tutorial complete through chapter 4

    peak.storage

        - unit tests for more complex object scenarios: references, thunks..?

        - lock management interfaces/API

        - docstrings for reference

    peak.model

        - clean up TW docstrings & interfaces

    peak.naming

        - useful example "flat" naming context (e.g. like AppUtils.URLkeys)

        - useful example hierarchical naming context (e.g. like JNDI's LDAP
          context or filesystem context)

        - rework smtp: to return a factory object that supports open().
          Also think about whether smtp should move elsewhere. Maybe
          there should be peak.network or peak.internet for things like
          smtp, ftp, etc contexts?

    peak.running

        - more docs for new 'cluster' tools

        - make 'cluster' parser complain about things that would cause
          the clusterit tools to choke or barf on the file, or which would
          produce ambiguous or unintended results.

        - finish misc tasks on peak.running.logs's TODO list

        - simple daemons comparable to those in MetaDaemon

        - unit tests for daemons

        - docstrings for reference

    peak.config

        - "Rule"-oriented configuration files (section specifies component
          rather than property name prefix), so that daemons and other simple
          apps can be fully configured and run via a config file.

    peak.util

        - docstrings for reference

        - more unit tests?














 Future Releases

  (Note: some of the below is held-over from TransWarp and may no longer be
  relevant as written, they are being kept on this list as placeholders for
  ideas or problem areas that may need to be re-considered in future.)


  Simulator/Module Inheritance

    * Need a strategy for handling "del" operations; they are currently
      untrapped.  This might be okay under most circumstances, but need to
      consider edge cases.

    * 'makeClass()' should probably become part of the core API, where
      it can be used to resolve __metaclass__ conflicts during the first
      pass of importing a module (prior to running 'setupModule()')


  Messaging/ObjectSpaces

    * Support for sending and receiving remote cache invalidation
      messages between RecordManagers.



















  peak.model

    * Marshalling interface in Services; implementations for Enumeration, etc.

    * More S-E-F metadata: features, subclasses, svc.<->class, nested services

    * A way to generate Z3 Interfaces from Feature-based specifications?

    * Implement WarpCORE-oriented structural model, w/Querying support

    * "Indexed" version of in-memory model?


    Queries

       * Refactor to use interfaces, if appropriate

       * Incorporate into AbstractModel?

         - Pros:

           * Queries always available

           * Each StructuralModel implementation can easily include its own
             performance-tuned version of the basic items.

         - Con: default implementation doesn't perform well on large datasets

       * How much of framework needs extensibility?  Should the predicate
         classes be placed in the StructuralModel's namespace so that predicates
         have their meaning assigned by the StructuralModel implementation?










  peak.metamodels.uml

    * Need to write an MMX or XMI -> Python generator, and hook it back up into
      the UML package, since we're right now relying on a module generated
      by code that depends on stuff which is going away.

    * Helper methods in Elements & Services for marshalling, common queries, etc.

    * Generator framework

      - Tagged values in stereotypes vs. main values?

      - Should tagged values be copied directly into templates?  Treated as
        Python expressions?

      - Should Services be generated using an Element class' "static"
        (class-scope) methods/attributes?

        - Are association-ends scoped?

        - Would it be better to seperate them?

      - What determines whether an implemented Service actually stores objects
        or delegates this to its subclass services?

    * Simple Zope product demo (upload XMI, then browse the model via the web)















  peak.metamodels.xmi

    * Re-org to self-contain all XMI stuff inside an _XMI sub-component/service

    * Document version of standard used

    * Metamodel identity/version checking

    * XMI.Writing

    * Strict parsing and/or diagnostics on files that don't match the metamodel?

    * UUID/GUID support

    * Support for advanced references, external references?

    * XML Namespaces (do any current XMI tools need this?  Which spec version
      requires this?)

    * DOM StructuralModel (so files can be edited without affecting vendor XMI
      extensions)

 
