\chapter{Introduction: Component-Based Development for Enterprise Applications}

\section{What is PEAK?}

PEAK is the ``Python Enterprise Application Kit". If you develop
``enterprise" applications with Python, or indeed almost any sort of
application with Python, PEAK may help you do it faster, easier, on a
larger scale, and with fewer defects than ever before. The key is
component-based development, on a reliable infrastructure. 

PEAK is based on several years of hard-won experience developing and
managing mission-critical Python enterprise applications. Its authors
have had to use and administer for some time, virtually all of the
technologies present in PEAK. Although nearly all of PEAK is being
written ``from scratch", it was created to replace existing tools that
we've enjoyed -- or struggled with -- over the years. 

Our apps require 24x7 availability for thousands of employees worldwide.
So anything we build has to be ``stone-axe reliable." We want debugging
to be a simple and painless process, so we've designed PEAK to make
applications ``easy to reason about". We use techniques like ``lazy
immutability" to prevent unintended side-effects, and ``complain early
and often" to ensure that broken code announces itself as broken
\emph{before} it causes bugs or data corruption to creep in.  We've learned
our reliability lessons from several previous generations of (mostly
unpublished) application and component frameworks, and applied them to
this new, best-of-breed framework. 














\subsection{What PEAK is for: Enterprise Applications} 

Enterprise applications are complex, reflecting the complexity of the
environments they exist in and support. The ``enterprise" is often a
large corporation with many subsidiaries, each of which may have been
acquired as a previously-independent company with its own product lines
and business processes. With each acquisition, an enterprise inherits
new ``legacy" systems, which must be integrated or phased out. Databases
and applications are legion, system administration is vital. There are
multiple developers, some inside the company, some outside, some from
different divisions. Repetition is everywhere, but also variation. For
example: the New York database is on the same back-end as the one in
London, but the data model is slightly different, and the time zones on
stored dates are different. One thing doesn't vary, however: the users
want new functionality, and they want it yesterday. 

In such an environment, non-functional requirements -- the ``ilities" of
development -- reign supreme. Reusability, configurability, flexibility,
extensibility, reliability, portability: these are the stuff
``enterprise" applications must be made of. The authors of PEAK have
built their professional reputations not only on their applications'
reliabilty, but on their speed of development as well. So PEAK
incorporates their best ideas for making application components highly
reusable, extensible, and configurable, ``right out of the box". 

















\subsection{What PEAK is part of: Python Enterprise} 

The value proposition of J2EE is that you can have industry standards,
whose implementations are supplied by competing vendors, to address
the ``ilities" across a variety of concerns, such as data storage,
component assembly, messaging systems, and so on.  But J2EE encompasses
over a dozen technologies of varying complexity and immense APIs.  Java
is also not a compact language, nor is it especially suited to rapid
development.  Last, but not least, the sheer scope of J2EE ensures that
implementations are resource-hungry, and complex to install, manage, and
maintain, especially for the smaller enterprise, or small department
within a larger enterprise.  If you wish to do more with less, J2EE is
probably not for you. 

Python, on the other hand, is an easy-to-use language that ``fits your
brain", and comes with ``batteries included".  Often an idea that takes
half a dozen classes and several hundred lines of convoluted code to
express in Java, can be expressed in two classes and less than a hundred
lines of crystal-clear Python.  Indeed, Python is so expressive that it
can take far less time for one to write an alternative implementation of
a J2EE technology in Python, than it takes to understand that technology
in the first place!  Many J2EE technology concepts were actually
developed independently in Python applications and libraries, long
before they appeared in Java.  But, compared to Java's marketing
juggernaut, Python tools for the enterprise have had relatively little
market exposure. 

And so, there is an increasing movement in the Python world to develop
and/or promote serious alternatives to J2EE technologies for use with
Python, so that developers can leverage Python's lower total cost of
ownership in application development and maintenance. The authors of
PEAK see PEAK as part of this larger ``Python Enterprise" movement, along
with the Zope 3 application server, and other Python APIs and
technologies. Zope 3 can be seen as an alternative to Java servlets,
JSP, and EJB containers for ``session beans" and ``message-driven beans".
PEAK supplies tools for creating the equivalents of ``managed beans" and
``entity beans", and for implementing parallels to other J2EE technologies
such as JNDI and JMS.  It is designed to integrate well with the Zope 3 
object publishing architecture, and with other Python Enterprise
technologies. (A detailed comparison of all the technologies in the J2EE
and Python Enterprise worlds is outside the scope of this tutorial, but
may be addressed later in a separate white paper.) 


\subsection{What PEAK is made of: Application Kit} 

So what are these PEAK technologies? PEAK is an application kit, and
applications are made from components.  PEAK provides you with a
component architecture, component infrastructure, and various
general-purpose components and component frameworks for building
applications. As with J2EE, the idea is to let you stop reinventing
architectural and infrastructure wheels, so you can put more time into
your actual application. 

The most basic part of PEAK is the component binding package: a set of
tools for constructing components out of other components, and ``binding"
separate components together. Then, PEAK supplies a component naming
package that provides a common API for associating names with
components, looking them up by name, and handling ``addresses" of objects
like database connections, mail servers, log or lockfiles, and other
infrastructure components. Third, PEAK supplies a component
configuration package, which makes it easy to provide utilities and
configuration data that ``trickle down" through the components of an
application. 

PEAK also supplies, or will supply, several other packages dealing with
application domain components, storage, transactions,
internationalization, and system operations such as task scheduling,
logging, and so on. But all of these other packages depend on the three
core packages of binding, naming, and configuration, which are the
subject of this tutorial.  Understanding how to use these core packages
is essential for building PEAK applications. 

Luckily, PEAK is compact. At the time we started writing this, the binding,
naming, and config packages consisted of only about 4,000 lines of Python
(including docstrings, comments, and whitespace, but not counting unit
test modules or shared utility modules). So it won't take you long to
master their use, with the help of this tutorial. 




\section{Using this Document}

\citetitle{Building Component-Based Applications with PEAK} introduces
the basic techniques for using the PEAK binding, naming, and config
packages to build flexible, reusable, and configurable applications from
components. To get the best results from this tutorial, you should:

\begin{itemize}

\item Have a solid grasp of the Python language, version 2.2 (we
recommend checking out \citetitle{What's New in Python 2.2} at
\url{http://www.amk.ca/python/2.2/} if you are familiar with earlier 
versions, but not 2.2).

\item Have some familiarity with Zope's \module{Interface} package, or at least
have read \citetitle{A Quick Introduction to Python Interfaces} at 
\url{http://www.zope.org/Wikis/Interfaces/InterfaceUserDocumentation}.

\item Have Python 2.2.1 or greater installed on your computer, along
with PEAK, so that you can try out the sample code and exercises in this
tutorial.

\end{itemize}

\subsection{Formatting Conventions}

This document uses the following formatting conventions:

\begin{itemize}

\item Code samples and the names of actual classes, functions, will be in a
\code{fixed pitch font}.

\item Text intended to be typed at a Python interpreter prompt is prefixed 
with the interpreter prompt, \samp{>>>}.

\item When a new, important term is first introduced, it will be marked
in \strong{boldface text}.

\end{itemize}

\section{Getting Started with PEAK}

\subsection{Package Layout and API Conventions}

PEAK is installed as a set of Python packages, such as \module{peak.binding},
\module{peak.naming}, and so on, within the top-level \module{peak} package
space.  To help distinguish between the ``public" and ``private" portions of
the code, each subpackage includes an \module{api} module or subpackage, which
exports all of the commonly-used classes, functions, and constants that form
that package's public API.

The top-level package also includes an API subpackage, \module{peak.api}, which
contains each of the other subpackages' API modules, named for the subpackage.
In other words, the following two lines produce similar results:

\begin{verbatim}
from peak.api import binding

from peak.binding import api as binding
\end{verbatim}

For convenience, you can also use \samp{from peak.api import *} to import all
the API subpackages.  Whichever approach you use to import the APIs you need,
you can access any \module{peak.binding} API class such as \class{Once}
by simply referring to \class{binding.Once}.  In this tutorial and all PEAK
documentation and code examples, we'll refer to APIs following this same
convention: major subpackage followed by a dot and the class or function name.

\begin{notice}
Experienced Python programmers may wonder whether using
\samp{from peak.api import *} will cause all of PEAK to be imported.  In
fact, it won't, because the \module{peak.api} subpackage uses a 
``lazy import" mechanism.  Individual API subpackages like \module{peak.binding}
won't be imported until they're actually used by your code, to prevent wasteful
up-front loading of all the modules and classes.  See the source for
\module{peak.api.__init__} and the \class{lazyModule} function in
\module{peak.binding.imports}, if you'd like to know more about how it works.
\end{notice} 



\subsubsection{Interfaces and Exceptions}

XXX peak.exceptions, where ``interfaces" modules are, ...?

\subsubsection{PEAK Subpackages and Modules}

\begin{description}

\item[binding] \hfill \\ 
The \module{peak.api} package supplies commonly used classes, functions,
modules, and singletons needed by PEAK applications and the PEAK framework
itself.

\item[binding] \hfill \\ 
The \module{peak.binding} package defines base classes for application
components, and for the attribute bindings used to connect components
together.  These base classes are used throughout PEAK to implement all
sorts of components.

\item[config] \hfill \\ 
The \module{peak.config} package provides a framework for ``placeful" and
``lazily immutable" lookups of configuration data, and provides a set of 
default ``root" components that live ``above" the normal component 
hierarchy, providing a place for global or ``placeless" configuration data
to live.  Configuration data can be arbitrary objects or values, and can
be looked up by either a property name, or by an interface that the desired
object supports (similar to the Zope 3 concept of \strong{utilities}).

\item[exceptions] \hfill \\ 
The \module{peak.exceptions} module contains the definitions of all exception
classes used by PEAK, except for those defined by modules in the
\module{peak.util} package.

\item[model] \hfill \\ 
The \module{peak.model} package provides a framework for creating persistent,
application domain class families.  It provides abstractions such as
"Structural Features" that can define fields and associations based on
metadata, and automatically generate methods for those features based on code
templates.  The resulting persistent classes can be saved or loaded by
subclassing \class{DataManager} classes from the \module{peak.storage} package.

\item[naming] \hfill \\ 
The \module{peak.naming} package provides services comparable to those of
Java's JNDI system, only easier to use and extend.  Naming services are
a standardized interface for looking up or recording the location of objects,
whether they're database connections, printers, web services, or even 
something as simple as log files.

\item[running] \hfill \\ 
The \module{peak.running} package provides runtime environment tools for
logging, locking, process control, etc.

\item[storage] \hfill \\ 
The \module{peak.storage} package provides services and components for
handling transactions, database connections, and persistence.

\item[util] \hfill \\ 
The \module{peak.util} package is a collection of generally useful modules
that don't rely on anything else in PEAK, and thus could be used
independently of PEAK.  Includes modules for dealing with Python bytecode,
XML handling, simple table-like data structures, UUID/GUID handling, and more.

\end{description}

XXX peak.metamodels, peak.tests, test subpackages


\subsection{Installing PEAK}














